
/*! \file test_colored_range_counting_wm2.cpp
    \brief A more advance test of the CRC WM creation + range search.
    \author Fabrizio Barisione
*/
#include<iostream>
#include <sdsl/suffix_arrays.hpp>
#include <sdsl/bit_vectors.hpp>
#include <sdsl/wavelet_trees.hpp>
#include <sdsl/wt_algorithm.hpp>
#include <unordered_map>
int main()
{
    //1.
    std::cout << ">> Starting test_wm" << std::endl;
    //Extract of BWT_P using wikidata reduced set. (1000 entries)
    //5 different values in the entire vector (excluding 0, which is a must). Remember valid values are >= 0.
    sdsl::int_vector<> S = {0, 420, 420, 576, 432, 576, 1, 420, 420, 1, 420, 420, 420, 576, 576, 432, 576, 420, 420, 420, 432, 1, 576, 576, 432, 420, 1, 432, 1, 420, 420, 432, 420, 1, 420, 432, 1, 432, 420, 1, 420, 432, 420, 1, 420, 420, 420, 420, 420, 576, 576, 576, 576, 576, 576, 432, 576, 576, 420, 420, 432, 1, 432, 1, 420, 420, 1, 420, 420, 420, 1, 420, 420, 420, 420, 420, 432, 1, 420, 420, 420, 420, 420, 420, 432, 420, 1, 432, 420, 1, 576, 1, 432, 1, 576, 420, 420, 432, 1, 420, 432, 1, 420, 576, 432, 576, 576, 420, 420, 432, 1, 432, 432, 1, 1, 1, 420, 1, 420, 432, 1, 420, 432, 1, 420, 420, 420, 576, 576, 420, 1, 420, 1, 420, 432, 420, 420, 1, 420, 576, 576, 576, 432, 420, 1, 420, 576, 432, 420, 1, 576, 432, 1, 576, 432, 1, 420, 420, 420, 420, 432, 420, 1, 576, 1, 420, 420, 1, 420, 420, 432, 420, 1, 420, 420, 420, 420, 420, 576, 576, 576, 420, 420, 420, 432, 1, 420, 420, 420, 576, 432, 576, 576, 420, 1, 1, 420, 432, 576, 420, 420, 1, 576, 432, 1, 576, 432, 1, 420, 1, 432, 1, 420, 420, 432, 432, 420, 1, 576, 432, 420, 1, 420, 432, 420, 1, 432, 1, 420, 576, 420, 420, 1, 576, 432, 420, 1, 576, 432, 420, 1, 432, 1, 1, 432, 420, 1, 420, 420, 432, 1, 432, 420, 1, 420, 420, 420, 420, 420, 420, 420, 420, 420, 576, 576, 576, 576, 576, 420, 1, 420, 432, 420, 1, 420, 576, 420, 1, 420, 432, 420, 1, 420, 420, 420, 420, 576, 432, 576, 576, 576, 576, 420, 420, 420, 420, 432, 432, 1, 420, 576, 432, 420, 1, 576, 576, 432, 576, 576, 420, 420, 432, 432, 1, 420, 420, 1, 420, 420, 432, 420, 420, 1, 432, 1, 576, 1, 1, 432, 420, 1, 420, 420, 420, 420, 420, 420, 576, 420, 1, 420, 576, 576, 432, 576, 1, 420, 576, 576, 432, 576, 1, 420, 576, 1, 420, 432, 576, 420, 1, 420, 1, 432, 420, 420, 420, 420, 432, 1, 576, 1, 432, 1, 420, 420, 576, 576, 432, 576, 576, 420, 420, 432, 1, 420, 420, 420, 576, 576, 576, 576, 420, 1, 576, 432, 420, 1, 420, 420, 420, 576, 576, 576, 432, 576, 432, 420, 420, 420, 420, 576, 576, 1, 420, 420, 576, 420, 576, 1, 1, 432, 420, 1, 420, 576, 432, 1, 420, 576, 432, 420, 1, 420, 576, 432, 420, 1, 420, 432, 420, 420, 420, 420, 1, 432, 420, 1, 420, 432, 576, 576, 432, 420, 576, 576, 576, 1, 576, 432, 576, 1, 420, 576, 432, 420, 1, 432, 1, 420, 432, 420, 1, 432, 576, 1, 420, 432, 420, 420, 432, 1, 576, 420, 1, 420, 576, 576, 576, 432, 420, 1, 432, 420, 1, 420, 576, 576, 420, 1, 420, 576, 576, 420, 576, 576, 576, 576, 1, 420, 420, 1, 432, 1, 576, 432, 1, 432, 1, 576, 420, 1, 420, 432, 420, 1, 420, 420, 576, 1, 432, 1, 420, 420, 420, 420, 420, 420, 420, 1, 420, 420, 576, 576, 576, 432, 420, 576, 1, 1, 432, 1, 432, 420, 1, 420, 420, 576, 576, 576, 576, 432, 576, 576, 576, 576, 576, 576, 576, 420, 420, 420, 420, 432, 576, 576, 576, 1, 420, 420, 420, 420, 420, 576, 576, 576, 576, 576, 420, 1, 576, 432, 1, 576, 576, 432, 1, 432, 1, 576, 432, 1, 1, 1, 420, 420, 576, 420, 1, 420, 1, 576, 432, 1, 420, 576, 576, 576, 576, 420, 420, 420, 420, 576, 1, 420, 420, 420, 420, 432, 1, 576, 1, 576, 1, 1, 420, 432, 420, 1, 420, 576, 576, 432, 420, 1, 576, 432, 1, 576, 432, 1, 432, 1, 420, 420, 576, 432, 420, 420, 432, 1, 420, 576, 432, 1, 420, 432, 1, 432, 1, 420, 420, 420, 420, 420, 420, 576, 420, 420, 432, 432, 1, 420, 432, 1, 420, 420, 420, 432, 420, 1, 420, 432, 420, 420, 420, 420, 432, 1, 420, 432, 1, 420, 432, 1, 420, 420, 420, 420, 432, 420, 1, 420, 420, 420, 432, 420, 1, 420, 420, 420, 432, 1, 420, 420, 420, 576, 432, 420, 1, 432, 432, 432, 432, 420, 1, 420, 1, 576, 432, 1, 576, 432, 1, 576, 1, 432, 1, 576, 432, 420, 1, 420, 576, 576, 432, 420, 576, 1, 432, 576, 1, 432, 1, 420, 420, 420, 420, 420, 1, 576, 432, 1, 420, 576, 1, 420, 576, 432, 1, 432, 1, 420, 576, 432, 420, 1, 420, 432, 420, 420, 432, 432, 1, 576, 1, 420, 420, 432, 1, 420, 420, 432, 1, 420, 420, 432, 1, 420, 432, 1, 420, 432, 420, 420, 420, 420, 1, 420, 420, 1, 420, 576, 420, 1, 432, 1, 420, 420, 420, 420, 420, 420, 432, 432, 576, 432, 420, 420, 432, 1, 420, 432, 1, 420, 420, 420, 420, 576, 432, 420, 420, 420, 420, 1, 420, 576, 1, 420, 1, 420, 576, 1, 576, 576, 432, 420, 420, 1, 420, 420, 420, 420, 420, 576, 576, 432, 420, 1, 432, 576, 420, 1, 432, 576, 1, 1, 576, 420, 1, 1, 576, 432, 1, 420, 420, 420, 576, 1, 432, 1, 432, 1, 576, 1, 420, 420, 432, 576, 576, 420, 1, 576, 432, 1, 576, 432, 1, 420, 420, 420, 432, 420, 1, 1, 432, 432, 420, 1, 576, 432, 420, 1, 420, 432, 432, 432, 432, 420, 1, 420, 420, 420, 576, 432, 420, 420, 420, 420, 420, 1, 420, 420, 420, 432, 420, 420, 420, 420, 420, 1, 420, 420, 420, 432, 420, 420, 420, 420, 420, 1, 576, 432, 420, 1, 420, 420, 420, 432, 420, 420, 420, 420, 420, 1, 432, 576, 1, 432, 432, 1, 432, 576, 1, 420, 420, 420, 420, 1, 420};
    sdsl::wm_int<sdsl::bit_vector> L;
    std::cout << "Buiding original WM based on S = " << S << std::endl;
    construct_im(L, S);

    //2.
    sdsl::int_vector<> C(S.size());
    std::cout << "Buiding CRC WM with size = " << C.size() << std::endl;
    uint64_t x_s = 0;
    uint64_t x_e = C.size();
    //O ( (x_e - x_s) * log sigma)
    {
        std::unordered_map<uint64_t, uint64_t> hash_map;
        for(uint64_t i = x_s; i < x_e; i++){
            auto it = hash_map.find(L[i]);
            if(it == hash_map.end()){
                hash_map.insert({L[i], i});
                C[i - x_s] = 0;
                std::cout << C[i] << " ";fflush(stdout);
            }else{
                C[i - x_s] = it->second + 1;
                std::cout << C[i] << " ";fflush(stdout);
                it->second = i;
            }
        }
    }
    std::cout << "" << std::endl;
    //3.
    //C es el arreglo C del paper de Muthukrishnan codificado como WT para S=abracadabra, con wtroot=00100010010 (ver 'wm_orig').
    //Finalmente, recordar que estamos trabajando con la variante Wavelet matrix por que esperamos alfabetos muy grandes.
    //La linea de abajo está comentada porque se calcula automáticamente en punto 2.
    //sdsl::int_vector<> C = {0, 0, 0, 1, 0, 4, 0, 6, 2, 3, 8};//Nombrado C por el Colored range count algorithm.
    std::cout << "C = " << C << std::endl;
    //vector<uint64_t> C_aux; // El arreglo "C" del WT.
    sdsl::wm_int<sdsl::bit_vector> wm;
    //sdsl::int_vector<> src;
    construct_im(wm, C);
    std::cout << "  size = " << wm.size() << std::endl;
    std::cout << "  sigma = " << wm.sigma << std::endl;
    std::cout << "  max_level = " << wm.max_level << std::endl;//efectivamente este WT tiene 4 niveles, porque son 11 symbolos, 2⁴ = 16 permite contener los 11 carácteres.
    std::cout << "  rank de 0s = " << wm.rank(wm.size(), 0) << std::endl;
    std::cout << "  rank de 8s = " << wm.rank(wm.size(), 8) << std::endl;
    //! This function counts distinct values on a range. It's based on Muthukrishnan's Colored range counting algorithm.
    //! See algorithm 2 here: https://users.dcc.uchile.cl/~gnavarro/ps/tcs11.2.pdf
    auto res = wm.range_search_2d(4,9,0,3, false);
    auto count = get<0>(res);
    std::cout << " # of Distinct values in range [4, 9] : " << count << std::endl;
    res = wm.range_search_2d(9,10,0,8, false);
    count = get<0>(res);
    std::cout << " # of Distinct values in range [9, 10] : " << count << std::endl;
    res = wm.range_search_2d(1,S.size(),0,0, false);//! Important: you must start from 1, not from 0.
    count = get<0>(res);
    std::cout << " # of Distinct values in full range [1, MAX_SIZE] : " << count << std::endl;
}